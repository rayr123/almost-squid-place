<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Almost Squid Place</title>

    <link rel="icon" type="image/x-icon" href="/favicon.ico" />

    <meta
      name="description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="almost-reddit-place.vercel.app" />
    <meta
      property="twitter:url"
      content="https://almost-reddit-place.vercel.app/"
    />
    <meta name="twitter:title" content="Almost Reddit Place" />
    <meta
      name="twitter:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta
      name="twitter:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <meta property="og:title" content="Almost Reddit Place" />
    <meta property="og:site_name" content="Almost Reddit Place" />
    <meta property="og:url" content="https://almost-reddit-place.vercel.app/" />
    <meta
      property="og:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Quicksand", sans-serif;
      }
      .custom-bg {
        background-color: linear-gradient(180deg, #f02e65 0%, #c81b4c 100%);
        background-image: url("/assets/bg.png");
        background-position: center;
        background-size: cover;
      }
      canvas {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/appwrite@7.0.0"></script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"
      integrity="sha512-NxocnqsXP3zm0Xb42zqVMvjQIktKEpTIbCXXyhBPxqGZHqhcOXHs4pXI/GoZ8lE+2NJONRifuBpi9DxC58L0Lw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script src="https://cdn.jsdelivr.net/gh/bgrins/TinyColor/dist/tinycolor-min.js"></script>

    <script>
      // You can define variable here with configurations for the application
      /*
      var globalConfig = {
        pixelsX: 10,
        pixelsY: 10
      }
      */
    </script>

    <script defer>
      var globalConfig = globalConfig || {};

      const appwrite = new Appwrite();

      appwrite
        .setEndpoint("https://appwrite.matejbaco.eu/v1")
        .setProject("almostRedditPlaceV2");

      function alpineSetup() {
        return {
          config: Object.assign(
            {},
            {
              delaySeconds: 10,

              pixelsX: 500,
              pixelsY: 500,

              colors: [
                "#ff0000",
                "#ff8700",
                "#ffd300",
                "#ffe5b4",
                "#ffc0cb",
                "#deff0a",
                "#a1ff0a",
                "#0aff99",
                "#228B22",
                "#0aefff",
                "#147df5",
                "#580aff",
                "#be0aff",
                "#ffffff",
                "#000000",
                "#654321",
                "#808080",
              ],
            },
            globalConfig
          ),

          state: {
            showInfoAlert: false,

            cooldown: null,
            interval: null,

            isColoring: false,

            currentPixelData: null,
            currentPixelShow: false,

            touch: {
              clientY: null,
              clientX: null,
            },

            isReady: false,

            debounce: null,

            selectedColor: "#ff0000",

            zoom: 1,
            isDragging: false,

            currentPixelPos: null,

            lastTouch: null,

            posX: 0,
            posY: 0,

            previousPixelColor: null,
            previousPixelPosition: null,

            pixels: {},
          },

          p5: null,
          canvas: null,
          sketch: null,

          async onColorPixel() {
            if (this.state.isColoring || this.state.currentPixelPos === null) {
              return;
            }

            try {
              this.state.isColoring = true;

              const color = this.state.selectedColor;
              const pixel = {
                x: this.state.currentPixelPos[0],
                y: this.state.currentPixelPos[1],
              };

              try {
                await appwrite.account.get();
              } catch (err) {
                throw new Error("To place pixels, you must sign in.");
              }

              const res = await appwrite.functions.createExecution(
                "colorPixel",
                JSON.stringify({
                  x: pixel.x,
                  y: pixel.y,
                  hex: color,
                }),
                false
              );

              if (res.stderr) {
                throw new Error(res.stderr);
              }

              const resJson = JSON.parse(
                decodeURIComponent(escape(res.stdout))
              );

              if (!resJson.success && resJson.message) {
                throw new Error(resJson.message);
              }

              if (resJson.skipDelay) {
                this.state.cooldown = 0;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
              } else {
                this.state.cooldown = this.config.delaySeconds;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
                this.state.interval = setInterval(() => {
                  this.state.cooldown--;

                  if (this.state.cooldown <= 0) {
                    if (this.state.interval) {
                      clearInterval(this.state.interval);
                    }
                  }
                }, 1000);
              }
            } catch (err) {
              console.error(err);
              if (err.message === "Too many requests") {
                err.message =
                  "You are too quick! You are not allowed to continue for a minute.";
              }
              alert(err.message);
            } finally {
              this.state.isColoring = false;
            }
          },

          async fetchUsingStorage() {
            documents = [];

            const fileRes = await appwrite.storage.listFiles(
              "pixels",
              undefined,
              1,
              undefined,
              undefined,
              undefined,
              "DESC"
            );

            const fileUrl = appwrite.storage.getFileDownload(
              "pixels",
              fileRes.files[0].$id
            );

            const jsonText = await (await fetch(fileUrl.href)).text();

            const json = JSON.parse(jsonText.split("}]}")[0] + "}]}");

            documents = json.docs;

            let cursor = undefined;
            hasNext = true;
            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                  "createdAt.greater(" + json.syncAt + ")",
                ],
                100,
                undefined,
                cursor,
                "after"
              );

              documents.push(...response.documents);

              if (response.documents.length > 0) {
                cursor = response.documents[response.documents.length - 1].$id;
              } else {
                hasNext = false;
              }
            } while (hasNext);

            return documents;
          },

          async fetchUsingDatabase() {
            documents = [];

            let cursor = undefined;
            hasNext = true;
            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                ],
                100,
                undefined,
                cursor,
                "after"
              );

              documents.push(...response.documents);

              if (response.documents.length > 0) {
                cursor = response.documents[response.documents.length - 1].$id;
              } else {
                hasNext = false;
              }
            } while (hasNext);

            return documents;
          },

          async fetchPixels() {
            documents = [];

            try {
              documents = await this.fetchUsingStorage();
            } catch (err) {
              console.error(err);
              alert(err.message);
            }

            for (const document of documents) {
              if (!this.state.pixels[document.$id]) {
                if (document.hex === "ffffff") {
                  if (this.state.pixels[document.$id]) {
                    delete this.state.pixels[document.$id];
                  }
                } else {
                  this.state.pixels[document.$id] = document;
                }
              }
            }

            this.render(true);
            this.calculateCenter();
          },

          calculateCenter() {
            const pixelSize = 1 * this.state.zoom;

            const k = this.state.zoom * (500 / 2);
            const left = -(this.state.posX - k);
            const top = -(this.state.posY - k);

            this.state.currentPixelPos = [
              Math.floor(left / pixelSize),
              Math.floor(top / pixelSize),
            ];

            if (this.state.previousPixelPosition !== null) {
              this.sketch.set(
                this.state.previousPixelPosition[0],
                this.state.previousPixelPosition[1],
                this.state.previousPixelColor
              );
              this.sketch.updatePixels();
            }

            const currentPixelColor = this.sketch.get(
              this.state.currentPixelPos[0],
              this.state.currentPixelPos[1]
            );

            const tinyColor = tinycolor(
              `rgb(${currentPixelColor[0]}, ${currentPixelColor[1]}, ${currentPixelColor[2]})`
            );

            let darkerPixelColorHex;
            if (tinyColor.isLight()) {
              darkerPixelColorHex = tinyColor.darken(35).toString();
            } else {
              darkerPixelColorHex = tinyColor.brighten(35).toString();
            }

            const clr = this.sketch.color(darkerPixelColorHex);
            this.sketch.set(
              this.state.currentPixelPos[0],
              this.state.currentPixelPos[1],
              clr
            );
            this.sketch.updatePixels();

            this.state.previousPixelColor = currentPixelColor;
            this.state.previousPixelPosition = this.state.currentPixelPos;

            const currentCursorPixel =
              this.state.pixels[
                `${this.state.currentPixelPos[0]}_${this.state.currentPixelPos[1]}`
              ];

            this.state.currentPixelShow = currentCursorPixel !== undefined;
            this.state.currentPixelData =
              currentCursorPixel === undefined
                ? this.state.currentPixelData
                : currentCursorPixel;
          },

          onMouseDown(event) {
            this.state.isDragging = true;
          },

          onMouseUp(event) {
            this.state.isDragging = false;
          },

          onTouchStart(event) {
            this.state.lastTouch = {
              x: event.touches[0].screenX,
              y: event.touches[0].screenY,
            };
          },

          onTouchEnd(event) {
            this.state.lastTouch = null;
          },

          onTouchMove(event) {
            event.preventDefault();
            event.stopPropagation();

            if (!this.state.lastTouch) {
              return;
            }

            const moveX = event.touches[0].screenX - this.state.lastTouch.x;
            const moveY = event.touches[0].screenY - this.state.lastTouch.y;

            this.state.posX += moveX;
            this.state.posY += moveY;

            this.calculateCenter();

            this.state.lastTouch = {
              x: event.touches[0].screenX,
              y: event.touches[0].screenY,
            };
          },

          onMouseMove(event) {
            if (!this.state.isDragging) {
              return;
            }

            const { movementY, movementX } = event;

            this.state.posX += event.movementX;
            this.state.posY += event.movementY;

            this.calculateCenter();
          },

          onScroll(event) {
            const originalDistance = this.state.zoom;

            let scroll = -event.deltaY;
            this.state.zoom += scroll / 200;

            this.checkZoom(originalDistance);

            event.preventDefault();
            event.stopPropagation();
          },

          init() {
            appwrite.subscribe(
              ["collections.pixelsPublic.documents"],
              (event) => {
                let d = Date.now();
                let isAction = false;
                let actionColor = null;
                let actionPos = null;

                if (
                  event.event === "database.documents.update" ||
                  event.event === "database.documents.create"
                ) {
                  if (event.payload.hex === "ffffff") {
                    if (this.state.pixels[event.payload.$id]) {
                      delete this.state.pixels[event.payload.$id];

                      isAction = true;
                      actionColor = "ffffff";
                      actionPos = event.payload.$id.split("_");
                    }
                  } else {
                    this.state.pixels[event.payload.$id] = event.payload;

                    isAction = true;
                    actionColor = event.payload.hex;
                    actionPos = event.payload.$id.split("_");
                  }
                }

                if (isAction) {
                  const pixelSize = 1 * this.state.zoom;

                  const k = this.state.zoom * (500 / 2);
                  const left = -(this.state.posX - k);
                  const top = -(this.state.posY - k);

                  const currentPos = [
                    Math.floor(left / pixelSize),
                    Math.floor(top / pixelSize),
                  ];

                  if (
                    +actionPos[0] == currentPos[0] &&
                    +actionPos[1] === currentPos[1]
                  ) {
                    this.state.previousPixelColor = this.sketch.color(
                      "#" + actionColor
                    );
                    this.calculateCenter();
                  }

                  const clr = this.sketch.color("#" + actionColor);
                  this.sketch.set(actionPos[0], actionPos[1], clr);
                  this.sketch.updatePixels();
                }
              }
            );

            setTimeout(() => {
              const s = (sketch) => {
                sketch.setup = () => {
                  var canvas = sketch.createCanvas(500, 500);

                  canvas.parent("appboard");

                  this.canvas = canvas;
                  this.sketch = sketch;

                  this.sketch.noStroke();

                  this.fetchPixels();
                };

                // DO NOT USE
                sketch.draw = () => {};

                sketch.keyPressed = (event) => {
                  if (
                    event.target.nodeName.toLowerCase() !== "canvas" &&
                    event.target.nodeName.toLowerCase() !== "body"
                  ) {
                    return;
                  }

                  if (event.key === " ") {
                    this.onColorPixel();
                    return;
                  }

                  if (!isNaN(event.key)) {
                    const colorIndex = +event.key - 1;
                    this.state.selectedColor = this.config.colors[colorIndex];
                    return;
                  }

                  let moveX = 0;
                  let moveY = 0;

                  if (
                    event.key === "A" ||
                    event.key === "a" ||
                    event.key === "ArrowLeft"
                  ) {
                    moveX = 1;
                  }

                  if (
                    event.key === "D" ||
                    event.key === "d" ||
                    event.key === "ArrowRight"
                  ) {
                    moveX = -1;
                  }

                  if (
                    event.key === "W" ||
                    (event.key === "w") | (event.key === "ArrowUp")
                  ) {
                    moveY = 1;
                  }

                  if (
                    event.key === "S" ||
                    event.key === "s" ||
                    event.key === "ArrowDown"
                  ) {
                    moveY = -1;
                  }

                  if (event.shiftKey) {
                    moveX *= 3;
                    moveY *= 3;
                  }

                  this.state.posX += moveX * this.state.zoom;
                  this.state.posY += moveY * this.state.zoom;
                  this.calculateCenter();
                };
              };

              this.p5 = new p5(s);
            }, 1);
          },

          toggleInfo() {
            this.state.showInfoAlert = !this.state.showInfoAlert;
          },

          goToCenter() {
            this.state.posX = 0;
            this.state.posY = 0;
            this.calculateCenter();
          },

          exportScreenshot() {
            const s = (sketch) => {
              sketch.setup = () => {
                const { pixels } = this.state;
                const { pixelsX, pixelsY } = this.config;

                const canvas = sketch.createCanvas(pixelsX, pixelsY);
                sketch.pixelDensity(1);

                const clrBackground = sketch.color("#ffffff");
                for (let x = 0; x < pixelsX; x++) {
                  for (let y = 0; y < pixelsY; y++) {
                    sketch.set(x, y, clrBackground);
                  }
                }

                for (const pixel in pixels) {
                  const pixelData = pixels[pixel];
                  const clr = sketch.color("#" + pixelData.hex);
                  sketch.set(pixelData.x, pixelData.y, clr);
                }

                sketch.updatePixels();

                sketch.saveCanvas(canvas, "myCanvas", "png");
              };
            };

            const p5Screenshot = new p5(s);
          },

          zoomOut() {
            const originalDistance = this.state.zoom;
            this.state.zoom /= 1.5;

            this.checkZoom(originalDistance);
          },

          zoomIn() {
            const originalDistance = this.state.zoom;
            this.state.zoom *= 1.5;

            this.checkZoom(originalDistance);
          },

          checkZoom(originalZoom) {
            if (this.state.zoom < 1) {
              this.state.zoom = 1;
            }
            if (this.state.zoom > 100) {
              this.state.zoom = 100;
            }

            const originalWidth = +document
              .querySelector("#defaultCanvas0")
              .style.width.split("px")[0];
            const originalHeight = +document
              .querySelector("#defaultCanvas0")
              .style.height.split("px")[0];

            const newWidth = 500 * this.state.zoom;
            const newHeight = 500 * this.state.zoom;

            document.querySelector("#defaultCanvas0").style.width =
              newWidth + "px";
            document.querySelector("#defaultCanvas0").style.height =
              newHeight + "px";

            const originalDistance = this.distanceFromCenter(
              this.state.posX,
              this.state.posY,
              originalZoom
            );
            const newDistance = this.distanceFromCenter(
              this.state.posX,
              this.state.posY,
              this.state.zoom
            );

            const diffX = originalDistance[0] - newDistance[0];
            const diffY = originalDistance[1] - newDistance[1];

            this.state.posX += diffX;
            this.state.posY += diffY;

            this.calculateCenter();
          },

          distanceFromCenter(x, y, zoom) {
            const middleX = zoom * (500 / 2);
            const middleY = zoom * (500 / 2);

            const diffX = middleX - (x + 500 / 2) * zoom;
            const diffY = middleY - (y + 500 / 2) * zoom;

            return [diffX / this.state.zoom, diffY / this.state.zoom];
          },

          render(forced = false) {
            const { pixelsX, pixelsY } = this.config;

            if (!forced && !this.state.isReady) {
              return;
            }

            this.state.isReady = true;

            //          this.sketch.pixelDensity(1);
            const clrBackground = this.sketch.color("#ffffff");
            for (let x = 0; x < pixelsX; x++) {
              for (let y = 0; y < pixelsY; y++) {
                this.sketch.set(x, y, clrBackground);
              }
            }

            this.renderPixels();

            this.sketch.updatePixels();
          },

          printDate(date) {
            if (!date) {
              return "No date";
            }

            const d = new Date(date);

            const min =
              d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes();
            const hour = d.getHours() < 10 ? "0" + d.getHours() : d.getHours();
            const day = d.getDate() < 10 ? "0" + d.getDate() : d.getDate();
            let m = d.getMonth() + 1;
            const month = m < 10 ? "0" + m : m;

            return `${day}.${month} at ${hour}:${min}`;
          },

          renderPixels() {
            const { pixels } = this.state;

            for (const pixel in pixels) {
              const pixelData = pixels[pixel];
              const clr = this.sketch.color("#" + pixelData.hex);
              this.sketch.set(pixelData.x, pixelData.y, clr);
            }
          },
        };
      }

      const app = alpineSetup();
    </script>
  </head>
  <body>
    <div x-data="app">
      <div class="fixed inset-0 bg-primary custom-bg z-[5]"></div>

      <div class="relative z-10 flex flex-col min-h-screen px-3 min-w-screen">
        <div
          class="absolute bottom-0 left-0 w-full h-20 bg-gradient-to-t from-black to-primary opacity-10"
        ></div>

        <img
          class="absolute z-10 hidden left-10 bottom-10 sm:block"
          src="/assets/dots-bl.svg"
          alt=""
        />
        <img
          class="absolute z-10 hidden right-10 top-10 sm:block"
          src="/assets/dots-tr.svg"
          alt=""
        />

        <div
          class="relative z-20 flex flex-col items-center justify-center h-[100vh] py-10"
        >
          <div
            class="flex-shrink-0 flex items-center mb-2 justify-center space-x-3"
          >
            <h1 class="text-white font-bold text-3xl text-center">
              Almost Reddit Place
            </h1>

            <template hidden x-if="!state.isReady">
              <svg
                class="w-6 h-6 animate-spin text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
            </template>
          </div>

          <template hidden x-if="!state.isReady">
            <p
              class="flex-shrink-0 mt-2 text-white font-bold text-lg text-center"
            >
              From time to time, we need to load a big file. Please be patient
              if load takes up to a minute.
            </p>
          </template>

          <div
            class="h-full mt-4 touch-manipulation container bg-white rounded-xl overflow-hidden relative"
          >
            <div
              x-show="state.currentPixelShow"
              x-transition:enter="transition ease-out duration-300"
              x-transition:enter-start="opacity-0 scale-90"
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-300"
              x-transition:leave-start="opacity-100 scale-100"
              x-transition:leave-end="opacity-0 scale-90"
              class="pointer-events-none absolute -space-y-1 flex-col z-10 bottom-4 left-0 w-full flex items-center justify-center"
            >
              <div
                x-text="state.currentPixelData ? printDate(state.currentPixelData.createdAt) : ''"
                class="p-1 px-2 text-xs text-slate-200 bg-slate-500 rounded-lg"
              ></div>
              <div
                x-text="state.currentPixelData ? state.currentPixelData.userId : ''"
                class="p-2 text-sm text-slate-500 bg-slate-900 rounded-lg"
              ></div>
            </div>

            <div class="relative h-full overflow-hidden bg-[#e2e8f0]">
              <div class="z-10 absolute top-4 left-4 flex flex-col space-y-4">
                <button
                  x-on:click="toggleInfo()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>

                <button
                  x-on:click="goToCenter()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>
              </div>

              <div class="z-10 absolute top-4 right-4 flex flex-col space-y-4">
                <button
                  x-on:click="zoomIn()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"
                    />
                  </svg>
                </button>
                <button
                  x-on:click="zoomOut()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"
                    />
                  </svg>
                </button>
              </div>

              <div
                x-on:wheel="onScroll($event)"
                x-on:mousedown="onMouseDown($event)"
                x-on:mouseup="onMouseUp($event)"
                x-on:mousemove="onMouseMove($event)"
                x-on:touchmove="onTouchMove($event)"
                x-on:touchend="onTouchEnd($event)"
                x-on:touchcancel="onTouchEnd($event)"
                x-on:touchstart="onTouchStart($event)"
                class="w-full h-full flex items-center justify-center"
              >
                <div
                  class="w-full h-full flex items-center justify-center"
                  id="appboard"
                  x-bind:style="'transform: translate(' + state.posX + 'px, ' + state.posY + 'px)'"
                ></div>
              </div>
            </div>
          </div>

          <div
            class="flex-shrink-0 mt-3 container bg-white rounded-xl p-4 grid grid-cols-12 gap-4"
          >
            <div
              class="overflow-x-auto col-span-12 md:col-span-8 flex flex-row space-x-3 items-center h-full"
            >
              <template x-for="(color, i) in config.colors" :key="i">
                <div class="relative flex items-center justify-center h-full">
                  <template x-if="state.selectedColor === color">
                    <div
                      class="pointer-events-none absolute left-0 top-0 h-full items-center w-full flex justify-center"
                    >
                      <div
                        class="p-[3px] rounded-full bg-slate-900 border-white flex items-center justify-center text-white"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          class="h-3 w-3"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                          stroke-width="2"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                      </div>
                    </div>
                  </template>

                  <button
                    x-on:click="state.selectedColor = color"
                    x-bind:class="state.selectedColor === color ? 'border-2 border-slate-900' : 'border border-slate-200'"
                    class="rounded-full w-10 h-10"
                    x-bind:style="'background-color:' + color"
                  ></button>
                </div>
              </template>
            </div>

            <template
              hidden
              x-data="{loaded: false}"
              x-init="setTimeout(() => { loaded = true }, 1)"
              x-if="loaded"
            >
              <div class="col-span-12 md:col-span-4">
                <template hidden x-if="$store.authModal.accountProfile">
                  <button
                    x-on:click="onColorPixel()"
                    x-bind:class="state.cooldown <= 0 ? 'bg-[#f02e65]' : 'bg-orange-400 opacity-50'"
                    class="flex items-center justify-center space-x-3 text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
                  >
                    <template hidden x-if="state.cooldown <= 0"
                      ><p>Color Pixel</p></template
                    >

                    <template hidden x-if="state.cooldown > 0"
                      ><p
                        x-text="'Color in ' + state.cooldown + (state.cooldown <= 1 ? ' second' : ' seconds')"
                      ></p
                    ></template>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>

                <template hidden x-if="!$store.authModal.accountProfile">
                  <button
                    x-on:click="$store.authModal.open()"
                    class="flex items-center justify-center space-x-3 text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
                  >
                    <p>Sign in to Color</p>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>
              </div>
            </template>
          </div>

      <div
        x-show="state.showInfoAlert"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0"
        x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-300"
        x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0"
        class="fixed z-[9999] inset-0"
        style="display: none; font-family: 'Montserrat', sans-serif"
      >
        <div class="w-full h-full relative">
          <div
            class="absolute inset-0 bg-black opacity-50"
            x-on:click="toggleInfo()"
          ></div>
          <div
            class="relative w-full h-full pt-10 overflow-y-auto pb-10"
            x-on:click="toggleInfo()"
          >
            <div
              class="mx-auto w-full max-w-2xl rounded-xl bg-white p-6"
              x-on:click="$event.stopPropagation()"
            >
              <div class="flex justify-between items-center">
                <h1 class="text-auth-gray-900 mb-4 text-2xl font-bold">
                  Getting Started
                </h1>
                <button
                  type="button"
                  x-on:click="toggleInfo()"
                  class="p-3 transition-colors duration-200 transform rounded-md hover:bg-opacity-25 hover:bg-gray-600 focus:outline-none"
                >
                  <svg
                    class="w-5 h-5"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      d="M6 18L18 6M6 6L18 18"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    ></path>
                  </svg>
                </button>
              </div>
              <div class="mt-6 prose">
                <p>Welcome to Almost Reddit Place 👋</p>

                <p>
                  I decided to create this project to showcase what
                  <a
                    href="https://appwrite.io/docs/installation"
                    class="text-[#f02e65]"
                    >Appwrite</a
                  >
                  is capable of and learn how to work with canvas on a website.
                  I took the idea from Reddit Place, where the Reddit team added
                  a minigame similar to this one for a few weeks after April
                  Fools' Day 🤪
                </p>

                <p>
                  In this game, anyone can color 1 pixel of 500x500 canvas every
                  10 seconds. There is a palette of colors you can pick from to
                  create your masterpiece. If you want to work on a big
                  painting, feel free to invite your friends to help you 🖼️
                </p>

                <i class="italic"
                  >Fun fact: Appwrite implementation took less than 2 hours!</i
                >

                <h3>✨ Tips and Tricks</h3>

                <ul>
                  <li>
                    Center of the canvas is your cursor. This means that if you
                    paint a pixel, it will paint the one in the middle of the
                    canvas. You can drag&drop with your mouse to move around the
                    canvas to move this cursor. The cursor is visible, so there
                    shouldn't be any problem painting any pixel you want. If it
                    feels tricky selecting a specific pixel, you can zoom in to
                    make it easier.
                  </li>
                  <li>
                    If you focus inside canvas (click it), you can now use WASD
                    (or arrows) to move around. Hold SHIFT to move 3 pixels
                    instead of one. You can also use numbers on the keyboard to
                    switch colors and press SPACE to paint the pixel.
                  </li>
                  <li>
                    If canvas lags on your device, you can zoom in. The more you
                    are zoomed-in, the fewer pixels your device needs to render,
                    the faster it is.
                  </li>
                  <li>
                    If you paint the pixel white, it resets the pixel. You won't
                    see your name on such a pixel, it will become an empty
                    pixel.
                  </li>
                  <li>
                    If you register, the first part of your email becomes your
                    username. The username is publicly visible, so feel free to
                    create a fake account if you don't want to share your email.
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
